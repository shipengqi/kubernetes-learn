<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Kubernetes learning | Service </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/kubernetes-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/kubernetes-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"Service","path":"service-discovery/service.html"},"data":{"navigation":{"logo":{"text":"Kubernetes Learn","type":"link","path":"index.html"},"main":[{"text":"核心组件","type":"label"},{"text":"Kubernetes 核心组件","type":"link","path":"components/README.html"},{"text":"ETCD","type":"link","path":"components/etcd.html"},{"text":"kube-apiserver","type":"link","path":"components/apiserver.html"},{"text":"kube-scheduler","type":"link","path":"components/scheduler.html"},{"text":"kube-controller-manager","type":"link","path":"components/controller-manager.html"},{"text":"kubelet","type":"link","path":"components/kubelet.html"},{"text":"kube-proxy","type":"link","path":"components/proxy.html"},{"text":"kube-dns","type":"link","path":"components/dns.html"},{"text":"kubectl","type":"link","path":"components/kubectl.html"},{"text":"Federation","type":"link","path":"components/federation.html"},{"text":"Pod","type":"label"},{"text":"Pod 简介","type":"link","path":"pod/README.html"},{"text":"Pod 生命周期","type":"link","path":"pod/lifecycle.html"},{"text":"Init 容器","type":"link","path":"pod/init.html"},{"text":"Pod 安全策略","type":"link","path":"pod/pod-security-policy.html"},{"text":"Pod Preset","type":"link","path":"pod/pod-preset.html"},{"text":"Pod 中断与 PDB","type":"link","path":"pod/pdb.html"},{"text":"集群资源管理","type":"label"},{"text":"Node","type":"link","path":"cluster/node.html"},{"text":"Namespace","type":"link","path":"cluster/namespace.html"},{"text":"Label","type":"link","path":"cluster/label.html"},{"text":"Annotation","type":"link","path":"cluster/annotation.html"},{"text":"Taints 和 tolerations","type":"link","path":"cluster/taint.html"},{"text":"垃圾收集","type":"link","path":"cluster/garbage-collection.html"},{"text":"控制器","type":"label"},{"text":"Deployment","type":"link","path":"controller/deployment.html"},{"text":"StatefulSet","type":"link","path":"controller/stateful-set.html"},{"text":"DaemonSet","type":"link","path":"controller/daemon-set.html"},{"text":"ReplicaSet","type":"link","path":"controller/rc-rs.html"},{"text":"Job","type":"link","path":"controller/job.html"},{"text":"CronJob","type":"link","path":"controller/cron-job.html"},{"text":"Horizontal Pod Autoscaling","type":"link","path":"controller/hpa.html"},{"text":"准入控制","type":"link","path":"controller/admission.html"},{"text":"服务发现","type":"label"},{"text":"Service","type":"link","path":"service-discovery/service.html"},{"text":"Ingress","type":"link","path":"service-discovery/ingress.html"},{"text":"身份与权限","type":"label"},{"text":"身份与权限控制","type":"link","path":"auth/README.html"},{"text":"认证","type":"link","path":"auth/authentication.html"},{"text":"授权","type":"link","path":"auth/authorization.html"},{"text":"Service Account","type":"link","path":"auth/service-account.html"},{"text":"RBAC","type":"link","path":"auth/rbac.html"},{"text":"STORAGE","type":"label"},{"text":"Secret","type":"link","path":"storage/secret.html"},{"text":"ConfigMap","type":"link","path":"storage/configmap.html"},{"text":"Volume","type":"link","path":"storage/volume.html"},{"text":"Persistent Volume","type":"link","path":"storage/pv.html"},{"text":"StorageClass","type":"link","path":"storage/storageclass.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/kubernetes-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/kubernetes-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/kubernetes-learn/index.html" class="doc-navbar__logo"><img src="/kubernetes-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Kubernetes Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>Pod 是有生命周期的，它们可以被创建，也可以被销毁，并且创建 Pod 时， pod 会动态获取 IP 地址。也就是说 pod 的 ip 是变化的。<br>所以当集群内的 pod 要访问另一个 pod 时，通过 ip 是不可靠的。</p>
<p>因为，Kubernetes 定义了 <code>Service</code> 对象。 <strong>Service 是对一组提供相同功能的 Pods 的抽象，并为它们提供一个统一的入口</strong>。<br>借助 Service，应用可以方便的实现服务发现与负载均衡，并实现应用的零宕机升级。Service 通过 <a href="../cluster/label.html">Label Selector</a> 来选取服务后端，<br>一般配合 Replication Controller 或者 Deployment 来保证后端容器的正常运行。<br>这些匹配标签的 Pod IP 和端口列表组成 endpoints，由 <code>kube-proxy</code> 负责将服务 IP 负载均衡到这些 endpoints 上。</p>
<p>比如，一个 backend pod 要访问 mysql pod，mysql 有三个副本， backend 不需要关心 mysql pod 可能会发生的变化，Service 定义的抽象能够解耦这种关联。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Service 有四种类型， <code>spec.type</code> 的取值以及行为如下：</p>
<ul>
<li>ClusterIP：默认类型，自动分配一个仅 cluster 内部可以访问的虚拟 IP</li>
<li>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过 <code>&lt;NodeIP&gt;:NodePort</code> 来访问该服务，简单的说就是暴露一个节点的端口。<br>如果 <code>kube-proxy</code> 设置了 <code>--nodeport-addresses=10.240.0.0/16</code>（v1.10 支持），那么该 NodePort 仅对设置在范围内的 IP 有效。</li>
<li>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部的负载均衡器，并将请求转发到 <code>&lt;NodeIP&gt;:NodePort</code></li>
<li>ExternalName：将服务通过 DNS CNAME 记录方式转发到指定的域名（通过 <code>spec.externlName</code> 设定）。需要 kube-dns 版本在 1.7 以上。</li>
</ul>
<h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>设置 <code>type</code> 的值为 “NodePort”，Kubernetes master 将从给定的配置范围内（默认：<code>30000-32767</code>）分配端口。<br>每个 Node 将从该端口（每个 Node 上的同一端口）代理到 Service。该端口将通过 Service 的 <code>spec.ports[*].nodePort</code> 字段被指定。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mattermost-svc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">core</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mm-server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8065</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8065</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">8065</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">mattermost</span></span><br></pre></td></tr></table></figure>
<h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>使用支持外部负载均衡器的云提供商的服务，设置 <code>type</code> 的值为 “LoadBalancer”，将为 Service 提供负载均衡器。<br>负载均衡器是异步创建的，关于被提供的负载均衡器的信息将会通过 Service 的 <code>status.loadBalancer</code> 字段被发布出去。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress-frontend-svc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">core</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">ingress-frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"https"</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">  loadBalancerIP:</span> <span class="number">78.11</span><span class="number">.24</span><span class="number">.19</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">ingress-frontend</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  loadBalancer:</span></span><br><span class="line"><span class="attr">    ingress:</span></span><br><span class="line"><span class="attr">      - ip:</span> <span class="number">146.148</span><span class="number">.47</span><span class="number">.155</span></span><br></pre></td></tr></table></figure>
<p>来自外部负载均衡器的流量将直接打到 backend Pod 上，不过实际它们是如何工作的，这要依赖于云提供商。 在这些情况下，将根据用户设置的 <code>loadBalancerIP</code> 来创建<br>负载均衡器。 某些云提供商允许设置 <code>loadBalancerIP</code>。如果没有设置 <code>loadBalancerIP</code>，将会给负载均衡器指派一个临时 IP。 如果设置了 <code>loadBalancerIP</code>，但云提供<br>商并不支持这种特性，那么设置的 <code>loadBalancerIP</code> 值将会被忽略掉。</p>
<h2 id="外部-IP"><a href="#外部-IP" class="headerlink" title="外部 IP"></a>外部 IP</h2><p>如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 <code>externalIPs</code>。 通过外部 IP（作为目的 IP 地址）进入<br>到集群，打到 Service 的端口上的流量，将会被路由到 Service 的 Endpoint 上。 <code>externalIPs</code> 不会被 Kubernetes 管理。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="attr">  externalIPs:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">80.11</span><span class="number">.12</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p><code>externalIPs</code> 可以同任意的 ServiceType 来一起指定。 在下面的例子中，<code>my-service</code> 可以在 <code>80.11.12.10:80</code>（外部 IP:端口）上被客户端访问。</p>
<p><code>externalIPs</code> 字段填入 IP 地址之后，<code>kube-proxy</code> 会增加对应的 iptables 规则， 当有以对应 IP 为目标的流量发送到 Node 节点时，iptables 将进行 NAT，将<br>流量转发到对应的服务上。一般情况下，很少会遇到服务器接受非自身绑定 IP 流量的情况，所以 <code>externalIPs</code> 不常被使用，但配合网络层的其他工具，<br>它可以实现给 Service 绑定外部 IP 的效果。</p>
<p><code>externalIP</code> 是指能够被路由到 kubernetes 节点的 IP 地址，在公有云上，也就是我们所说的公网IP。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Kubernetes 支持2种基本的服务发现模式 —— 环境变量和 DNS。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>当 Pod 运行在 Node 上，kubelet 会为每个活跃的 Service 添加一组环境变量。 它同时支持 <a href="https://docs.docker.com/network/links/" target="_blank" rel="noopener">Docker links兼容</a> 变量<br>（查看 <code>makeLinkVariables</code>）、简单的 <code>{SVCNAME}_SERVICE_HOST</code> 和 <code>{SVCNAME}_SERVICE_PORT</code> 变量，这里 Service 的名称需要大写，横线被转换成下划线。</p>
<p>举个例子，一个名称为 “redis-master” 的 Service 暴露了 TCP 端口 6379，同时给它分配了 Cluster IP 地址 <code>10.0.0.11</code>，这个 Service 生成了如下环境变量：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br></pre></td></tr></table></figure></p>
<p><strong>这意味着一个 Pod 想要访问的一个 Service， 那么这个 Service 必须在 Pod 自己之前被创建，否则这些环境变量就不会被赋值。DNS 没有这个限制</strong>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>一个可选（强烈推荐）<a href="https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/README.html" target="_blank" rel="noopener">集群插件</a> 是 DNS 服务器。<br>DNS 服务器监视着创建新 Service 的 Kubernetes API，从而为每一个 Service 创建一组 DNS 记录。如果整个集群的 DNS 一直被启用，那么所有的 Pod 应该能够自动对 Service 进行名称解析。</p>
<p>例如，有一个名称为 <code>&quot;chatbot-svc&quot;</code> 的 Service，它在 Kubernetes 集群中名为 <code>&quot;core&quot;</code> 的 Namespace 中，为 <code>&quot;chatbot-svc.core&quot;</code> 创建了一条 DNS 记录。<br>在名称为 <code>&quot;core&quot;</code> 的 Namespace 中的 Pod 可以直接通过 Service 的名称 <code>&quot;chatbot-svc&quot;</code> 访问该 service。 但是如果在另一个 Namespace 中的 Pod 必须<br>以全名 <code>&quot;chatbot-svc.core&quot;</code> 访问该 service。</p>
<p>Kubernetes 也支持对端口名称的 DNS SRV（Service）记录。 如果名称为 <code>&quot;chatbot-svc.core&quot;</code> 的 Service 有一个名为 “http” 的 TCP 端口，<br>可以对 “_http._tcp.chatbot-svc.core” 执行 DNS SRV 查询，得到 “http” 的端口号。</p>
<p>Kubernetes DNS 服务器是唯一的一种能够访问 <code>ExternalName</code> 类型的 Service 的方式。</p>
<h2 id="Service-定义"><a href="#Service-定义" class="headerlink" title="Service 定义"></a>Service 定义</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">chatbot-svc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">core</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">slack-auth</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">4000</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">4000</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">msteams-auth</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">chatbot</span></span><br></pre></td></tr></table></figure>
<p>上面的例子定义了一个 <code>chatbot-svc</code> 的 service 对象，它会将请求代理到 pods 的 TCP 端口 4000 和 8080，并且 pod 的 label 要具有 <code>app: chatbot</code>。<br><strong>当服务需要多个端口时，每个端口都必须设置一个 <code>name</code> 字段</strong>。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Service、Endpoints 和 Pod 支持三种类型的协议：</p>
<ul>
<li>TCP</li>
<li>UDP</li>
<li>SCTP（Stream Control Transmission Protocol，流控制传输协议），用于通过IP网传输</li>
</ul>
<p>如果 <code>protocol</code> 字段未定义，默认是 TCP。</p>
<h2 id="不指定-selector-的-Service"><a href="#不指定-selector-的-Service" class="headerlink" title="不指定 selector 的 Service"></a>不指定 selector 的 Service</h2><p>在创建 Service 的时候，也可以不指定 Selectors，用来将 service 转发到 kubernetes 集群外部的服务（而不是 Pod）。例如：</p>
<ul>
<li>希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。</li>
<li>希望服务指向另一个 Namespace 中或其它集群中的服务。</li>
<li>正在将工作负载转移到 Kubernetes 集群，和运行在 Kubernetes 集群之外的 backend。</li>
</ul>
<p>两种方法定义没有 <code>selector</code> 的 Service。</p>
<h3 id="自定义-endpoint"><a href="#自定义-endpoint" class="headerlink" title="自定义 endpoint"></a>自定义 endpoint</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">      - ip:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">      - port:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Endpoints 的 IP 地址不能是 loopback <code>127.0.0.0/8</code>、link-local <code>169.254.0.0/16</code> 和 link-local 多播 <code>224.0.0.0/24</code>，也不能是 Kubernetes 中其他服务的 clusterIP</strong>。</p>
</blockquote>
<h3 id="DNS-转发"><a href="#DNS-转发" class="headerlink" title="DNS 转发"></a>DNS 转发</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ExternalName</span></span><br><span class="line"><span class="attr">  externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure>
<p>在 service 定义中指定 <code>externalName</code>。此时 DNS 服务会给 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 创建一个 CNAME 记录，<br>其值为 <code>my.database.example.com</code>。并且，该服务不会自动分配 Cluster IP，需要通过 service 的 DNS 来访问。</p>
<h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p>Headless Service 即不需要 Cluster IP 的服务。有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，<br>可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>None</code> 来创建 Headless Service。</p>
<p>这个选项允许开发人员自由寻找他们自己的方式，从而降低与 Kubernetes 系统的耦合性。 应用仍然可以使用一种自注册的模式和适配器，对其它需要发现机制的系统能够很容易地基于这个 API 来构建。</p>
<p>对这类 Service 并不会分配 Cluster IP，<code>kube-proxy</code> 不会处理它们，而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了 <code>selector</code>。</p>
<ul>
<li>定义了 Selectors 的 Headless Service，Endpoint 控制器在 API 中创建了 <code>Endpoints</code> 记录，并且修改 DNS 配置返回 A 记录（地址），通过这个<br>地址直接到达 Service 的后端 Pod 上。</li>
<li>不定义 Selectors 的 Headless Service，但设置 <code>externalName</code>，即上面的 <strong>DNS 转发</strong>，通过 CNAME 记录处理</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tcp-80-80-3b6tl</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  revisionHistoryLimit:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="attr">nginx:latest</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询创建的 nginx 服务</span></span><br><span class="line">$ kubectl get service --all-namespaces=<span class="literal">true</span></span><br><span class="line">NAMESPACE     NAME         CLUSTER-IP      EXTERNAL-IP      PORT(S)         AGE</span><br><span class="line">default       nginx        None            &lt;none&gt;           80/TCP          5m</span><br><span class="line">kube-system   kube-dns     172.26.255.70   &lt;none&gt;           53/UDP,53/TCP   1d</span><br></pre></td></tr></table></figure>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/kubernetes-learn/script/doc.js"></script>

    

  </body>
</html>
