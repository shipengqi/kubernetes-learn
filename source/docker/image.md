# Image

docker 镜像由 layer 组成。docker 负责堆叠这些 layers，并将它们表示为一个单一的对象。

查看 image 的分层 `docker inspect` 可以获取 容器/镜像 的元数据。

`docker history`  可以查看指定镜像的构建历史。

所有的 docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。

在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合

举一个简单的例子，两个镜像层分别包含 3 个文件，那么镜像就包含了来自两个镜像层的 6 个文件。
如果上层更新了下层的文件，那么镜像会显示上层最新的文件

## 共享镜像层

多个镜像之间可以共享 layer。

比如 `docker pull` 的时候，可能会出现 `xsdfasdfasf :Already exists` 类似的提示，表示某个 layer 已经在本地
存在，会使用已存在的 layer 来组成镜像。

## 镜像散列值 （摘要）

镜像只是一个配置对象，包含组成该镜像的 layer 列表和一些元数据信息。

layer 才是实际存储数据的地方，比如文件

layer 之间完全独立

镜像的唯一标识是一个加密 ID，即配置对象本身的散列值。
每个 layer 也由一个加密ID区分，其值为镜像层本身内容的散列值。


这意味着修改镜像的内容或其中任意的 layer，都会导致加密散列值的变化。所以，镜像和其镜像层都是不可变的，任何改动都能很轻松
地被辨别

这就是所谓的内容散列（Content Hash）。


在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。
但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！

这显然是个问题。
例如，在推送镜像层到 Docker Hub 的时候，Docker Hub 会尝试确认接收到的镜像没有在传输过程中被篡改。为了完成校验，Docker Hub 会
根据镜像层重新计算散列值，并与原散列值进行比较。因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。

为避免该问题，每个镜像层同时会包含一个**分发散列值**（Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服
务拉取或者推送镜像的时候，其中就包含了分发散列值，该散列值会用于校验拉取的镜像是否被篡改过。


## 多架构镜像
docker 运行一个应用就像非常简单。无须担心安装、依赖或者配置的问题。开箱即用。

随着多架构的支持，比如 Windows、ARM。拉取镜像是就需要考虑是否与当前架构匹配。

docker（镜像和镜像仓库服务）规范现在已经支持多架构镜像。

一个镜像标签之下可以支持多个平台和架构。